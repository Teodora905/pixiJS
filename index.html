<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script> 
</head>
<body>
  <div id="slot-container">
   
  </div>
  <div id="message"></div>
  <div id="spin-button"></div>
  <style>
    #slot-container canvas {
      width: 100%;
    }
  </style>

  <script type="module">
    //import * as PIXI from 'https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js';
    
    const slotContainer = document.getElementById('slot-container');
    const message = document.getElementById('message');

    const imageNames = [
      'symbol_jack',
      'symbol_9',
      'symbol_ace',
      'symbol_queen',
      'symbol_king',
      'symbol_axe',
      'symbol_brain',
      'symbol_rifle',
      'symbol_crow',
      'symbol_10',
    ];

    const app = new PIXI.Application({
      width: 800,
      height: 600,
      backgroundColor: 0x1099bb,
    });
    app.stage.sortableChildren = true;
    slotContainer.appendChild(app.view);
   
    
    const reelContainer = new PIXI.Container();
    reelContainer.sortableChildren = true;
    app.stage.addChild(reelContainer);
    
    PIXI.Assets.add('spritesheet', './assets/spritesheet/codingTaskAssets.json');
    
    
    PIXI.Assets.load('spritesheet').then((spritesheet) => {
      console.log('spritesheet 12', spritesheet);
      
      imageNames.forEach((name, index) => {
        const textureName = `${name}.png`; // Add the .png extension
        const sprite = new PIXI.Sprite(spritesheet.textures[textureName]);

        sprite.zIndex = 2;
        sprite.width = 50;
        sprite.height = 50;
        sprite.x = index * 50; // horizontal spacing
        sprite.y = 100; // Keep them on the same row
        reelContainer.addChild(sprite);

      })

      const background = PIXI.Sprite.from(spritesheet.textures['background.jpg']);
      background.zIndex = -1;
      background.width = app.screen.width;
      background.height = app.screen.height;
      app.stage.addChild(background);

      const highlight = new PIXI.Sprite(spritesheet.textures['winframe.png']);
      highlight.zIndex = 3;
      highlight.width = 50; // Adjust to match your sprite size
      highlight.height = 50; 
      highlight.x = 100;
      highlight.y = 100;
      highlight.visible = true;
      app.stage.addChild(highlight);

      const button = new PIXI.Sprite(spritesheet.textures['spin_button.png']);
      button.zIndex = 1;
      button.interactive = true;
      button.width = 50; // Adjust to match your sprite size
      button.height = 50; 
      button.x = 150;
      button.y = 150;
      button.buttonMode = true;
      app.stage.addChild(button);

      const message = new PIXI.Text('Press the button', {
        fontFamily: 'Arial',
        fontSize: 25,
        fill: 0xffffff,
        align: 'center'
      });
      message.zIndex = 1;
      message.x = 150;
      message.y = 150;
      app.stage.addChild(message);

      button.on('pointerdown', () => {
        const randomIndex = Math.floor(Math.random() * imageNames.length);
        console.log('randomIndex', randomIndex);
        const stopPosition = (-randomIndex * 50) + 100; // Assuming symbol height is 100px
        const duration = 1000; // Duration of the movement in milliseconds (2 seconds)
        const targetX = stopPosition; // The target x position
        const tween = new TWEEN.Tween(reelContainer)
          .to({ x: targetX }, duration)  // Move to targetX over `duration`
          .easing(TWEEN.Easing.Quadratic.Out) // Ease out for smooth transition
          .start(); // Start the tween animation
        
        app.ticker.add((delta) => {
          TWEEN.update(); 
        });

        setTimeout(() => {
          const winningSymbol = imageNames[randomIndex];
          message.text = `${winningSymbol} wins $${parseFloat(randomIndex*10).toFixed(2)}`;
          
        }, 1000); // Wait for animation to complete
       
      });
      
      

    }).catch((error) => {
        console.error("Failed to load spritesheet:", error);
    });
  
    
    function test1() {
      document.getElementById('slot-container').appendChild(app.view);
    //const reelContainer = new PIXI.Container();
    //app.stage.addChild(reelContainer);
    const json = PIXI.Assets.load("./assets/spritesheet/codingTaskAssets.json");
    console.log('json',json);
    //const myArr = JSON.parse(json);
    //console.log('myArr', myArr);
   
    json.then((resolvedTexture) =>{
        console.log('resolvedTexture 123', resolvedTexture);
        console.log('resolvedTexture.data.meta.image',resolvedTexture.data.meta.image);
        /*const spritesheet = new PIXI.Spritesheet(
            PIXI.Texture.from(resolvedTexture.data.meta.image),
            resolvedTexture
        );
        spritesheet.parse().then(() => {
          console.log('spritesheet', spritesheet);
        }).catch((error) => {
          console.error('Error parsing spritesheet:', error);
        });*/
        
        resolvedTexture.data.animations = {
          'symbols': ['symbol_9.png', 'symbol_10.png']
        }
      const anim = new PIXI.AnimatedSprite(resolvedTexture.data.animations.symbols);
      console.log('anim', anim);
      console.log('resolvedTexture.textures', resolvedTexture.textures);
      const symbols = resolvedTexture.textures;
      const symbolSprites = [];
      //symbolSprites = symbols.filter((symbol) => symbol.startsWith("symbol_"));
      //console.log('symbolSprites', symbolSprites);
      symbolSprites.push(symbols['symbol_9.png'], symbols['symbol_10.png'], symbols['symbol_ace.png'], symbols['symbol_axe.png'], symbols['symbol_brain.png'], symbols['symbol_crow.png'], symbols['symbol_jack.png'], symbols['symbol_king.png'],symbols['symbol_king.png'], symbols['symbol_rifle.png']);
      console.log('symbolSprites', symbolSprites);
  
    
    });

    }
      
  </script>
</body>
</html>
